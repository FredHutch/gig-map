#!/usr/bin/env python3
"""Standalone script to render a gig-map as static files."""
import argparse
import logging
import os
from plotly import colors
from time import sleep

from helpers import filter_alignments
from helpers import read_data
from helpers import render_gig_map_heatmap
from helpers import order_genes_nested
from helpers import set_figure_height

def start_redis_server(rdb_fp, port=6379, host="127.0.0.1"):
    """Start a redis server in the background which loads data from an RDB file."""
    logger = logging.getLogger('gig-map')

    # If the path to the RDB is not provided as an absoluate path
    if not os.path.isabs(rdb_fp):

        # Add the current working directory to make the relative path an absolute path
        rdb_fp = os.path.join(os.getcwd(), rdb_fp)
    
    assert os.path.exists(rdb_fp), f"Could not find file {rdb_fp}"

    # Get the name of the file separate from the name of the folder containing it
    folder, filename = os.path.split(rdb_fp)

    # Make sure that we've parsed the full file path correctly
    assert os.path.exists(os.path.join(folder, filename)), f"Resolved filename incorrectly ({os.path.join(folder, filename)})"

    cmd = f"redis-server --port {port} --bind {host} --dbfilename '{filename}' --dir {folder} &"
    logger.info(f"Running command: {cmd}")
    os.system(cmd)

    # Wait for the server to start (20 seconds at the maximum)
    for _ in range(20):
        if os.system("redis-cli ping") == 0:
            break
        sleep(1)

def stop_redis_server():
    cmd = "redis-cli shutdown nosave"
    logger.info(f"Running command: {cmd}")
    os.system(cmd)


def render_display(
    rdb=None,
    output_folder=os.getcwd(),
    output_prefix="gig-map",
    gene_annotations=None,
    genome_annotations=None,
    min_pctid=90.,
    min_cov=90.,
    color_genes_by="pident",
    query=None,
    host="127.0.0.1",
    port=6379,
    clustering_method="ani",
    max_n_genomes=None,
    min_genes_per_genome=1,
    min_genomes_per_gene=1,
    colorscale="blues",
    tree_width=0.4,
    label_genomes_by="",
    max_genome_label_len=60,
    max_gene_label_len=60,
    label_genes_by="",
    figure_height=1200,
    figure_width=1200,
    skip_gene_resort=False,
):
    """Main function for rendering the gig-map display as a static file."""
    logger = logging.getLogger('gig-map')

    # Make sure that the colorscale is recognized
    msg = f"--colorscale {colorscale} is not recognized in Plotly"
    assert colorscale in colors.named_colorscales(), msg
    
    # Read and format the data
    logger.info("Reading input data")
    data = read_data(
        dict(
            host=host,
            port=port,
            gene_annotations=gene_annotations,
            genome_annotations=genome_annotations
        )
    )

    # Filter the data and format a DataFrame
    plot_df = filter_alignments(
        data=data,
        clustering_method=clustering_method,
        max_n_genomes=max_n_genomes,
        min_pctid=min_pctid,
        min_cov=min_cov,
        min_genes_per_genome=min_genes_per_genome,
        min_genomes_per_gene=min_genomes_per_gene,
        query=query,
        # All genomes will be plotted, no subgroups
        ani_threshold="None",
        selected_group=0,
    )

    # If the user has not prevented gene resorting
    if not skip_gene_resort:

        # Sort the genes by linkage clustering
        data, plot_df = order_genes_nested(data, plot_df)

    # Set the figure height
    figure_height = set_figure_height(plot_df, figure_height)

    # Call the wrapper function to generate a go.Figure
    fig = render_gig_map_heatmap(
        data,
        plot_df,
        {
            "color-genes-by": color_genes_by,
            "clustering-method": clustering_method,
            "heatmap-colorscale": colorscale,
            "label-genomes-by": label_genomes_by,
            "label-genes-by": label_genes_by,
            "ani-threshold": "None",
            "tree-width": tree_width,
            "figure-height": figure_height,
            "figure-width": figure_width,
            "max-genome-label-len": max_genome_label_len,
            "max-gene-label-len": max_gene_label_len,
        },
        0
    )

    # Format the output file path
    output_fp = os.path.join(output_folder, f"{output_prefix}.html")

    # Write out to HTML
    fig.write_html(output_fp)

    # Make sure that we were able to write to the expected path
    msg = f"Could not write to {output_fp}"
    assert os.path.exists(output_fp), msg

    logger.info(f"Wrote out to {output_fp}")


if __name__ == "__main__":

    ##################
    # SET UP LOGGING #
    ##################

    # Set the level of the logger to INFO
    logFormatter = logging.Formatter(
        '%(asctime)s %(levelname)-8s [gig-map] %(message)s'
    )
    logger = logging.getLogger('gig-map')
    logger.setLevel(logging.INFO)

    # Write to STDOUT
    consoleHandler = logging.StreamHandler()
    consoleHandler.setFormatter(logFormatter)
    logger.addHandler(consoleHandler)

    ###################
    # PARSE ARGUMENTS #
    ###################

    # Create the parser
    parser = argparse.ArgumentParser(
        description='Render a display showing the distribution of annotated genes across microbial genomes'
    )

    # Add the arguments
    parser.add_argument(
        '--rdb',
        type=str,
        default=None,
        help='Data file containing the output of the gig-map analysis pipeline'
    )
    parser.add_argument(
        '--output-folder',
        type=str,
        required=True,
        help='Folder used to write output files'
    )
    parser.add_argument(
        '--output-prefix',
        type=str,
        default="gig-map",
        help='Prefix used for output files (the .html suffix will be added)'
    )
    parser.add_argument(
        '--gene-annotations',
        type=str,
        default=None,
        help='(optional) Annotations for genes to use for plotting (must contain a column named `gene_id`)'
    )
    parser.add_argument(
        '--genome-annotations',
        type=str,
        default=None,
        help='(optional) Annotations for genomes to use for plotting (must contain a column named `genome_id`)'
    )
    parser.add_argument(
        '--min-pctid',
        type=float,
        default=90,
        help='Minimum amino acid similarity threshold for displayed alignments (default: 90)'
    )
    parser.add_argument(
        '--min-cov',
        type=float,
        default=90,
        help='Minimum alignment coverage threshold for displayed alignments (default: 90)'
    )
    parser.add_argument(
        '--color-genes-by',
        type=str,
        default="pident",
        help='(optional) Indicate a column from the gene annotation table to use for coloring genes'
    )
    parser.add_argument(
        '--label-genomes-by',
        type=str,
        default="",
        help='(optional) Indicate a column from the genome annotation table used for labeling'
    )
    parser.add_argument(
        '--figure-height',
        default="auto",
        help="""
        By default, automatically scale figure height with the number of genomes.
        Alternately, specify an integer number of pixels to set the total figure height.
        (default: auto)
        """
    )
    parser.add_argument(
        '--figure-width',
        type=int,
        default=1200,
        help='Figure width in pixels (default: 1200)'
    )
    parser.add_argument(
        '--max-genome-label-len',
        type=int,
        default=60,
        help='Maximum number of characters allowed for genome labels (default: 60)'
    )
    parser.add_argument(
        '--max-gene-label-len',
        type=int,
        default=60,
        help='Maximum number of characters allowed for gene labels (default: 60)'
    )
    parser.add_argument(
        '--label-genes-by',
        type=str,
        default="",
        help='(optional) Indicate a column from the gene annotation table used for labeling'
    )
    parser.add_argument(
        '--clustering-method',
        type=str,
        default="ani",
        help='Method used to cluster genomes, either "ani" or the name of a specific marker (default: ani)'
    )
    parser.add_argument(
        '--min-genes-per-genome',
        type=int,
        default=1,
        help='(optional) Do not display any genome found in fewer than this number of genes'
    )
    parser.add_argument(
        '--min-genomes-per-gene',
        type=int,
        default=1,
        help='(optional) Do not display any gene found in fewer than this number of genomes'
    )
    parser.add_argument(
        '--max-n-genomes',
        type=int,
        default=None,
        help='(optional) Set a maximum number of genomes to display, removing genomes with the fewest aligned genes'
    )
    parser.add_argument(
        '--query',
        type=str,
        default=None,
        help="""
        (optional) Filter the genes for display based on a string containing boolean logic to be applied to gene annotations.
        For example, if the gene annotation file contains a column of numeric values with a header of `length`, then the query string
        "length >= 100" would limit the set of genes which are ultimately displayed to only those genes for which the value
        in the `length` column is >= 100.
        """
    )
    parser.add_argument(
        '--colorscale',
        type=str,
        default="blues",
        help='(optional) Plotly colorscale used for heatmap'
    )
    parser.add_argument(
        '--tree-width',
        type=float,
        default=0.4,
        help='Proportional size of tree used for plotting (default: 0.4)'
    )
    parser.add_argument(
        '--host',
        type=str,
        default="127.0.0.1",
        help='IP used to host redis server used to read alignment data (default: 127.0.0.1)'
    )
    parser.add_argument(
        '--port',
        type=int,
        default=6379,
        help='Port used to host redis server used to read alignment data (default: 6379_'
    )
    parser.add_argument(
        '--skip-gene-resort',
        action="store_true",
        help='If specified, use the prespecified gene order. This will prevent the time-consuming recalculation of linkage clustering.'
    )

    # Parse the arguments
    args = parser.parse_args()

    # Start the redis server
    start_redis_server(args.rdb, host=args.host, port=args.port)

    # Render the display
    try:
        render_display(**args.__dict__)

    # Whenever we've stopped, either due to an error or otherwise
    finally:

        # Shut down the redis server
        stop_redis_server()
