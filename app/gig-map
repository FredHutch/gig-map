#!/usr/bin/env python3

# Import the menu-driven-figure library
from menu_driven_figure.app import MenuDrivenFigure

import argparse
from dash import callback_context as ctx
from dash.exceptions import PreventUpdate
from dash.dependencies import Input, Output, ALL
from direct_redis import DirectRedis
from functools import lru_cache
import json
import logging
import numpy as np
import os
import pandas as pd
import plotly.graph_objects as go
from plotly import colors
from redis.exceptions import BusyLoadingError
from skbio import DistanceMatrix, TreeNode
from skbio.tree import nj
from time import sleep

####################
# HELPER FUNCTIONS #
####################

def remove_genome_file_ext(fp):
    for ext in ['.gz', '.fna', '.fasta', '.fa']:
        if fp.endswith(ext):
            fp = fp[:-len(ext)]
    return fp


def read_alignments(r):
    """Read in the alignment information from redis"""

    # Get the logger
    logger = logging.getLogger('gig-map')

    # Try to get the list of keys used to store slices of the alignments
    logger.info("Reading alignment shard keys")
    alignments_keys = r.get("alignments_keys")

    # If there are no keys
    if alignments_keys is None:

        # Just read in all of the alignments directly
        logger.info("Reading unsharded alignments")
        return r.get("alignments")

    # Otherwise, if there are keys
    else:

        logger.info("Reading alignments in shards")
        # Read in all of the chunks and combine them
        return pd.concat(map(r.get, alignments_keys))


def read_data(args):
    """Read in the data needed to render the heatmap."""

    # Get the logger
    logger = logging.getLogger('gig-map')

    # Return data formatted as a dict
    output = dict()

    # The default annotations available for each gene are the
    # alignment identity and coverage
    output["available_gene_annotations"] = [
        dict(
            label="Alignment Identity",
            value="pident"
        ),
        dict(
            label="Alignment Coverage",
            value="coverage"
        )
    ]

    # By default, there are no additional labels to apply to the genes
    output["available_gene_labels"] = []

    # Open the redis store for reading
    logger.info(f"Connecting to redis at {args['host']}:{args['port']}")
    with DirectRedis(host=args['host'], port=args['port']) as r:

        # Wait for the database to load - up to 120 seconds
        for _ in range(120):

            # Try to load the keys
            try:
                _ = r.keys()
                break

            # Catch the BusyLoadingError
            except BusyLoadingError:
                logger.info("Redis is loading...")
                sleep(1)

        # Log the available keys, to help with debugging
        logger.info("Available keys in redis:")
        for k in r.keys():
            logger.info(k)

        # Read in the alignment information in long format
        logger.info("Reading alignments")
        output["alignments"] = read_alignments(r)
        assert output["alignments"] is not None

        # Get the mapping of genome_ix to filenames
        logger.info("Reading genome index")
        output["genome_ix"] = r.get("genome_ix")
        assert output["genome_ix"] is not None

        # Add the genome names to the alignments table
        output["alignments"] = output["alignments"].assign(
            genome_name = output["alignments"].genome_ix.apply(
                lambda i: output["genome_ix"][i]
            )
        )

        # Get the mapping of gene_ix to strings
        logger.info("Reading gene index")
        output["gene_ix"] = r.get("gene_ix")
        assert output["gene_ix"] is not None

        # Read in the pairwise genome distances, merging multiple shards
        output["distances"] = pd.concat(
            [
                r.get(redis_key)
                for redis_key in r.get("distances_keys")
            ]
        )
        logger.info("Read in distances")

        # Read the genome groups which have been pre-computed
        # Results will be output to keys in data formatted as:
        # "genome_groups {threshold}"
        # "genome_group_df {threshold}"
        # "group_distance_df {threshold}"
        # Keep track of all possible values for `threshold`
        output["genome_group_thresholds"] = set([])
        for key in r.keys():
            if key.startswith(("genome_groups ", "genome_group_df ", "group_distance_df ")):
                # Save the data
                output[key] = r.get(key)
                # Parse the threshold value
                threshold_value = int(key.rsplit(" ", 1)[-1])
                # Add the threshold value
                output["genome_group_thresholds"].add(threshold_value)
        
        # Format output["genome_group_thresholds"] as a list
        output["genome_group_thresholds"] = list(output["genome_group_thresholds"])

        # Sort the keys numerically
        output["genome_group_thresholds"].sort()

        # Read in the t-SNE coordinates
        output["tsne"] = r.get("tsne")

    # Read in the gene annotations, if any
    if args['gene_annotations'] is None:
        output["gene_annotations"] = None

    # If a table was provided
    else:
        # Read in the table
        logger.info(f"Reading from {args['gene_annotations']}")
        output["gene_annotations"] = pd.read_csv(args['gene_annotations'])

        # Make sure that there is a column named "gene_id"
        msg = "Gene annotation CSV must contain a column named 'gene_id'"
        msg = f"{msg} - found {'; '.join(output['gene_annotations'].columns.values)}"
        assert "gene_id" in output["gene_annotations"].columns.values, msg

        # Set the index of the table as 'gene_id'
        output["gene_annotations"].set_index('gene_id', inplace=True)

        # Add the other columns to the available gene annotations
        for col_name in output["gene_annotations"].columns.values:
            output["available_gene_annotations"].append(
                dict(
                    label=col_name,
                    value=col_name,
                )
            )

            # Also add those columns to the options available for labeling genes
            output["available_gene_labels"].append(
                dict(
                    label=col_name,
                    value=col_name,
                )
            )

    # By default, there are no additional labels to apply to the genomes
    output["available_genome_labels"] = []

    # Read in the genome annotations, if any
    if args['genome_annotations'] is None:
        output['genome_annotations'] = None

    # If a table was provided
    else:
        # Read in the table
        logger.info(f"Reading from {args['genome_annotations']}")
        output['genome_annotations'] = pd.read_csv(args['genome_annotations'])

        # Make sure that there is a column named "genome_id"
        msg = "Genome annotation CSV must contain a column named 'genome_id'"
        msg = f"{msg} - found {'; '.join(output['genome_annotations'] .columns.values)}"
        assert "genome_id" in output['genome_annotations'] .columns.values, msg

        # Set the index of the table as 'genome_id'
        output['genome_annotations'] .set_index('genome_id', inplace=True)

        # Add the other columns to the available genome annotations
        for col_name in output['genome_annotations'] .columns.values:

            # Add those columns to the options available for labeling genomes
            output["available_genome_labels"].append(
                dict(
                    label=col_name,
                    value=col_name,
                )
            )

    logger.info("Done reading all data")

    # Return data formatted as a dict
    return output

def empty_plot():
    return go.Figure(
        layout=dict(
            xaxis=dict(
                visible=False
            ),
            yaxis=dict(
                visible=False
            ),
            plot_bgcolor="rgba(0, 0, 0, 0)",
            paper_bgcolor="rgba(0, 0, 0, 0)",
        )
    )


def get_node_positions(distance_df, y_offset=-0.5):
    """Construct a CartesianTree object from a set of distances."""

    # If there are more than two genomes/groups
    if distance_df.shape[0] > 2:

        # Format the distances as expected by skbio
        distances_dm = DistanceMatrix(
            distance_df.values, 
            list(map(str, distance_df.index.values))
        )

        # Make a neighbor-joining tree
        tree = nj(distances_dm)

        # Root at midpoint
        tree = tree.root_at_midpoint()

    # If there are only two genomes/groups
    elif distance_df.shape[0] == 2:

        # Get the distance betweeen the genomes/groups
        distance_between = distance_df.values[0, 1]

        # Make a simple tree linking the two
        tree = TreeNode(
            name='root',
            children=[
                TreeNode(
                    name=distance_df.index.values[0],
                    length=distance_between / 2.
                ),
                TreeNode(
                    name=distance_df.index.values[1],
                    length=distance_between / 2.
                )
            ]
        )

    # If there is only one genomes/groups
    elif distance_df.shape[0] == 1:

        # Make a simple tree with a single leaf
        tree = TreeNode(
            name='root',
            children=[
                TreeNode(
                    name=distance_df.index.values[0],
                    length=0
                )
            ]
        )

    # Assign x/y to create a DataFrame
    node_positions = CartesianTree(
        tree,
        y_offset=y_offset,
    )

    # Return that CartesianTree object
    return node_positions


# Generate a neighbor-joining tree from a subset of genomes
def make_nj_tree(genome_list, dists_df):

    # Make sure that we have distances for every genome
    for genome_id in genome_list:
        msg = f"Could not find a distance for genome {genome_id}"
        msg = f"{msg} -- best performance for FASTA files ending with .fasta[.gz] or .fna[.gz]"
        assert genome_id in dists_df.index.values, msg

    # Subset the distance matrix to the genomes in the list
    subset_dists = dists_df.reindex(
        columns=genome_list,
        index=genome_list,
    )

    # Get the positions of the nodes in the tree
    node_positions = get_node_positions(
        subset_dists,
        y_offset=-0.5,
    )

    # Lastly, make a mapping from the filenames to the same filename without any underscores
    filename_mapping = {
        fn.replace("_", " "): fn
        for fn in genome_list
    }

    # Now make a new list, ordered by the node_positions, with the complete
    # filenames (including the underscores)
    node_positions.genome_order = list(map(
        filename_mapping.get,
        node_positions.genome_order
    ))

    # Return the layout of the tree
    return node_positions


def plot_heatmap(plot_df, node_positions, selections, xaxis='x', yaxis='y'):
    """Return a heatmap rendered from the gene DataFrame and the genome positions."""

    # Format a set of wide tables
    tables = {
        table_key: plot_df.pivot(
            index="genome_name",
            columns="gene_ix",
            values=column_key
        ).sort_index(
            # Sorting on the column index preserves the t-SNE order
            axis=1
        ).reindex( 
            # Reorder the rows (genomes) to match the tree
            index=node_positions.genome_order,
        ).rename(
            # Transform the gene index to the gene ID string
            columns=lambda i: data["gene_ix"][i]
        )
        for table_key, column_key in [
            ("values", selections["color-genes-by"]),
            ("text", "description"),
        ]
    }

    # If the user elected to label the genes by something other than their ID
    if selections["label-genes-by"] != "":

        # Function to rename genes
        def format_gene_id(gene_id):

            # Get the value
            gene_label = data[
                "gene_annotations"
            ][
                selections["label-genes-by"]
            ].get(gene_id)

            # If there is no value
            if gene_label is None:

                # Just show the gene ID
                return gene_id

            # If there is a value
            else:

                # Join together the gene ID and the annotated label,
                #  up to a maximum length
                return f"{gene_label} ({gene_id})"[
                    :selections["max-gene-label-len"]
                ]

        # Rename the columns of the DataFrame
        for k in ["values", "text"]:
            tables[k] = tables[k].rename(
                columns=format_gene_id
            )

    return go.Heatmap(
        x=list(tables["values"].columns.values),
        z=tables["values"].values,
        text=tables["text"].values,
        xaxis=xaxis,
        yaxis=yaxis,
        colorscale=selections["heatmap-colorscale"],
        showscale=False,
        hovertemplate="%{text}<extra></extra>",
    )


def make_colormap(value_list, colorscale):
    # Adjust the range of values from 0 to 1
    norm_values = value_list.copy()
    norm_values.sort()
    norm_values = norm_values - norm_values.min()
    norm_values = norm_values / norm_values.max()
    return dict(
        zip(
            value_list,
            colors.sample_colorscale(
                colorscale,
                norm_values,
            )
        )
    )


def format_heatmap_rectangle(
    r,
    xaxis=None,
    yaxis=None,
):
    """Format a single rectangle in the heatmap."""
    return go.Scatter(
        x=[
            r.x - 0.5,
            r.x - 0.5,
            r.x + 0.5,
            r.x + 0.5,
        ],
        y=[
            r.y - 0.5,
            r.y + 0.5,
            r.y + 0.5,
            r.y - 0.5,
        ],
        fill="toself",
        hovertext=r.description,
        fillcolor=r.color,
        xaxis=xaxis,
        yaxis=yaxis,
        showlegend=False,
        mode="none",
    )


def plot_colorbar(
    min_val=0.,
    max_val=100.,
    colorscale="blues",
    color_genes_by="pctid",
    label="Percent Identity",
    xaxis="x3",
    yaxis="y2",
):
    """Render a colorbar as a heatmap on a dedicated axis."""

    value_list = [
        v
        for v in np.linspace(
            min_val, max_val, num=100
        )
    ]

    return go.Heatmap(
        y=[label],
        x=value_list,
        z=[value_list],
        xaxis=xaxis,
        yaxis=yaxis,
        colorscale=colorscale,
        showscale=False,
        hovertemplate="%{z}<extra></extra>",
    )

def plot_tree(node_positions, selections, xaxis='x', yaxis='y', try_relabel=True):
    """Return a Plotly trace rendered from a skbio tree."""

    # If the user decided to label the genomes
    if try_relabel and selections["label-genomes-by"] != "":

        # Replace the values in the 'name' column of the DataFrame used for plotting
        label_genomes_dict = data[
            "genome_annotations"
        ][
            selections["label-genomes-by"]
        ].to_dict()

        # If there is no annotation, keep the original label
        node_positions.df = node_positions.df.replace(
            to_replace=dict(
                name=lambda l: label_genomes_dict.get(l, l)
            )
        )

    # Return a ScatterGL
    yield go.Scattergl(
        name="Neighbor Joining Tree",
        showlegend=False,
        mode="lines",
        x=node_positions.x_coords(),
        y=node_positions.y_coords(),
        text=node_positions.text(),
        hoverinfo="text",
        xaxis=xaxis,
        yaxis=yaxis,
    )

    # Also show a set of dotted lines extending each tip
    yield go.Scattergl(
        showlegend=False,
        mode="lines",
        x=node_positions.extension_x_coords(),
        y=node_positions.extension_y_coords(),
        hoverinfo="skip",
        line=dict(
            color="black",
            dash="dot",
            width=1,
        ),
        xaxis=xaxis,
        yaxis=yaxis,
    )


class CartesianTree:

    def __init__(self, tree, y_offset=0, x=0):

        # Set up each position as a dict in a list
        # keys will be name, x, y, and parent
        self.positions = []

        # Assign the root, and then recurse down to the tips
        self.add_clade(tree, y_offset=y_offset, x=x)

        # Set up a DataFrame with the coordinates
        self.df = pd.DataFrame(self.positions)

        # Save the list of genome positions from the tree layout
        self.genome_order = self.df.query("is_leaf").set_index(
            "name"
        )[
            "y"
        ].sort_values().index.values

    def x_coords(self):
        """Return a list of x-coordinates to use for plotting the tree."""

        # Format is a list with each node and its parent, separated by NaN values
        return self._list_link_to_parents(col_name="x")

    def y_coords(self):
        """Return a list of y-coordinates to use for plotting the tree."""

        # Format is a list with each node and its parent, separated by NaN values
        return self._list_link_to_parents(col_name="y")

    def extension_x_coords(self):
        """Return a list of x-coordinates to extend the tips of the tree."""

        # Format is a list with each node and its parent, separated by NaN values
        return self._list_link_to_tips(col_name="x")

    def extension_y_coords(self):
        """Return a list of y-coordinates to extend the tips of the tree."""

        # Format is a list with each node and its parent, separated by NaN values
        return self._list_link_to_tips(col_name="y")

    def text(self):
        """Return a list of leaf labels to use for plotting the tree."""

        # Format is a list with each node and its parent, separated by NaN values
        return self._list_link_to_parents(col_name="name")

    def _list_link_to_parents(self, col_name="x"):
        """Internal method for generating a list of values from self.df"""

        # col_name may only be x, y, or name
        assert col_name in ['x', 'y', 'name'], f"Not recognized: {col_name}"

        # Populate a list which will be output
        output_list = []

        # Iterate over each row
        for _, r in self.df.iterrows():

            # If there is no parent for this row
            if pd.isnull(r['parent']) or r['parent'] < 0:

                # Skip it
                continue

            # If there is a parent for this row
            else:

                # Add the item to the list
                output_list.append(r[col_name])

                # The value placed in between the node and its parent
                # depends on whether it is X or Y (or name)

                # Get the value for the parent
                parent_val = self.df.loc[r['parent'], col_name]

                # Moving along the x axis
                if col_name == "x":

                    # The intermediate node has the X coordinate of the parent
                    output_list.append(parent_val)

                # Moving along the y axis
                elif col_name == "y":

                    # The intermediate node has the Y coordinate of the child
                    output_list.append(r[col_name])

                # For the 'name' values
                elif col_name == "name":

                    # The intermediate node has no name
                    output_list.append(None)

                # Add its parent
                output_list.append(parent_val)

                # Add a NaN to separate it
                output_list.append(None)

        # Return the list
        return output_list

    def _list_link_to_tips(self, col_name="x"):
        """Internal method: make a list of coordinates to extend the tips of the tree."""

        # col_name may only be x or y
        assert col_name in ['x', 'y'], f"Not recognized: {col_name}"

        # Populate a list which will be output
        output_list = []

        # Iterate over each row
        for _, r in self.df.iterrows():

            # If this is not a leaf
            if not r['is_leaf']:

                # Skip it
                continue

            # If this is a tip
            else:

                # Add the item to the list
                output_list.append(r[col_name])

                # Moving along the x axis
                if col_name == "x":

                    # Extend the tip to the maximum x for the table
                    output_list.append(self.df[col_name].max())

                # Moving along the y axis
                elif col_name == "y":

                    # Extending the tip will keep the same y coordinate
                    output_list.append(r[col_name])

                # Add a NaN to separate it
                output_list.append(None)

        # Return the list
        return output_list

    def add_clade(self, clade, y_offset=0, x=0, parent=-1):
        """Add the node at the base of a clade, then add its children (if any)."""

        # Set up a numeric ID for this clade
        clade_id = len(self.positions)

        # Calculate the number of tips for this clade
        clade_n_tips = len(list(clade.tips(include_self=True)))

        # The Y position is based on the total number of tips, and the offset
        clade_y = y_offset + (clade_n_tips / 2.)

        # The position of this clade is in the middle of max_y and min_y
        self.positions.append(
            dict(
                name=clade.name,
                x=x,
                y=clade_y,
                parent=parent,
                is_leaf=clade_n_tips==1
            )
        )

        # For each child
        for child in clade.children:

            # Calculate the number of tips for this child
            child_n_tips = len(list(child.tips(include_self=True)))

            # Calculate the x position of the clade by adding
            # the distance to its parent
            child_x = x + clade.distance(child)

            # Add the child
            self.add_clade(
                child,
                y_offset=y_offset,
                x=child_x,
                parent=clade_id,
            )

            # The next child will be positioned above, based on the number of tips
            y_offset = y_offset + child_n_tips

##################
# SET UP LOGGING #
##################

# Set the level of the logger to INFO
logFormatter = logging.Formatter(
    '%(asctime)s %(levelname)-8s [gig-map] %(message)s'
)
logger = logging.getLogger('gig-map')
logger.setLevel(logging.INFO)

# Write to STDOUT
consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logFormatter)
logger.addHandler(consoleHandler)


###################
# PARSE ARGUMENTS #
###################

# Create the parser
parser = argparse.ArgumentParser(
    description='Display the distribution of annotated genes across microbial genomes'
)

# Add the arguments
parser.add_argument(
    '--host',
    type=str,
    default="localhost",
    help='Redis host used for reading alignment data'
)
parser.add_argument(
    '--port',
    type=int,
    default=6379,
    help='Redis port used for reading alignment data'
)
parser.add_argument(
    '--gene-annotations',
    type=str,
    default=None,
    help='(optional) Annotations for genes to use for plotting (must contain a column named `gene_id`)'
)
parser.add_argument(
    '--genome-annotations',
    type=str,
    default=None,
    help='(optional) Annotations for genomes to use for plotting (must contain a column named `genome_id`)'
)
parser.add_argument(
    '--color-genes-by',
    type=str,
    default=None,
    help='(optional) Indicate a column from the gene annotation table to use for coloring genes'
)
parser.add_argument(
    '--settings',
    type=str,
    default=None,
    help='(optional) File containing initial settings for display'
)

# Parse the arguments
args = parser.parse_args()

# Read and format the data
data = read_data(args.__dict__)

# Define the menu items to be presented to the user
# The `menus` object is a list, which organizes the menus into tabs
menus = [
    # Second level is a dict, which defines the content of each menu tab
    # This example only has a single tab, but each additional dict
    # will add another tab to the menu display
    dict(
        # Label to be displayed at the top of the tab
        label="Customize Display",
        params=[
            # The distance threshold used to group genomes
            dict(
                # ID used to access the value of this menu item
                elem_id="ani-threshold",
                # Define the type of menu item
                type="dropdown",
                # Define the options in the dropdown
                options=[
                    dict(
                        value=v,
                        label=f"{int(v)}% Identity",
                    )
                    for v in data["genome_group_thresholds"]
                ] + [
                    dict(
                        value='None',
                        label="No Grouping"
                    )
                ],
                # Default value
                value=80.,
                # Suffix to display
                suffix="%",
                # Label displayed along this menu item
                label="Genome Group Clustering Threshold (ANI)",
            ),
            # The maximum number of genome groups to display
            dict(
                # ID used to access the value of this menu item
                elem_id="max-n-groups",
                # Define the type of menu item
                type="input",
                # Define the value type
                input_type="number",
                # Label displayed along this menu item
                label="Maximum Number of Genome Groups to Display",
                # Default value
                value=30,
            ),
            # The maximum number of genomes to display
            dict(
                # ID used to access the value of this menu item
                elem_id="max-n-genomes",
                # Define the type of menu item
                type="input",
                # Define the value type
                input_type="number",
                # Label displayed along this menu item
                label="Maximum Number of Genomes to Display",
                # Default value
                value=20,
            ),
            # Filter alignments by a minimum percent identity (similarity)
            dict(
                # ID used to access the value of this menu item
                elem_id="minimum-pctid",
                # Define the type of menu item
                type="input",
                # Define the value type
                input_type="number",
                # Label displayed along this menu item
                label="Minimum Alignment Identity",
                # Default value
                value=90.,
            ),
            # Filter alignments by a minimum coverage percentage
            dict(
                elem_id="minimum-coverage",
                # Define the type of menu item
                type="input",
                # Define the value type
                input_type="number",
                # Label displayed along this menu item
                label="Minimum Alignment Coverage",
                # Default value
                value=90.,
            ),
            # Filter genomes by a minimum number of genes aligned
            dict(
                elem_id="minimum-genes-per-genome",
                type="input",
                input_type="number",
                label="Minimum Number of Genes to Display Genome",
                value=10,
            ),
            # Allow the user to color the genes by the
            # coverage or identity of the alignment, as well
            # as any additional user-provided metadata
            dict(
                elem_id="color-genes-by",
                label="Color Genes By",
                type="dropdown",
                options=data['available_gene_annotations'],
                value="pident",
            ),
            # Set up the labels for each gene
            dict(
                elem_id="label-genes-by",
                label="Label Genes By",
                type="dropdown",
                options=data["available_gene_labels"],
                value="combined_name" if "combined_name" in data["gene_annotations"].columns.values else "",
            ),
            # Limit the length of each gene label
            dict(
                elem_id="max-gene-label-len",
                label="Maximum Gene Label Length",
                type="input",
                input_type="numeric",
                value=60,
                # Make sure that this option stays in the same column as the previous
                keep_with_previous=True
            ),
            # Set up the labels for each genome
            dict(
                elem_id="label-genomes-by",
                label="Label Genomes By",
                type="dropdown",
                options=data['available_genome_labels'],
                value="Formatted Name" if "Formatted Name" in data["genome_annotations"].columns.values else "",
            ),
            # Limit the length of each genome label
            dict(
                elem_id="max-genome-label-len",
                label="Maximum Genome Label Length",
                type="input",
                input_type="numeric",
                value=60,
                # Make sure that this option stays in the same column as the previous
                keep_with_previous=True
            ),
            # Set the colorscale used for the heatmap
            dict(
                elem_id="heatmap-colorscale",
                label="Heatmap Color Scale",
                type="dropdown",
                options=[
                    dict(label=v, value=v)
                    for v in colors.named_colorscales()
                ],
                value="blues",
            ),
            # Set the width of the tree
            dict(
                elem_id="tree-width",
                label="Tree Width",
                type="slider",
                min_val=0.1,
                max_val=0.9,
                value=0.4,
                step=0.01,
            ),
            # Set the width of the figure
            dict(
                elem_id="figure-width",
                label="Figure Width",
                type="slider",
                min_val=200,
                max_val=2400,
                value=1200,
                step=20,
            ),
            dict(
                elem_id="figure-height",
                label="Figure Height",
                type="slider",
                min_val=200,
                max_val=2400,
                value=1000,
                step=20,
            ),
        ]
    ),
]

# Keep a list of params that were considered, but aren't currently being used
deprecated_menu_items = [
    # Show a heatmap or a t-SNE map
    dict(
        # ID used to access the value of this menu item
        elem_id="display-type",
        # Label displayed along this menu item
        label="Display Type",
        # Dropdown
        type="dropdown",
        # Available options
        options=[
            dict(
                label="Heatmap + Tree",
                value="heatmap"
            ),
            dict(
                label="t-SNE Map",
                value="tsne"
            ),
        ],
        # Default value
        value="heatmap"
    ),
    # Allow the user to set a title to the plot
    dict(
        # ID used to access the value of this menu item
        elem_id="plot-title",
        # Label displayed along this menu item
        label="Plot Title",
        # Free-form input box
        type="input",
        # Input must be a string
        input_type="string",
        # Default value
        value="",
    ),
]


@lru_cache(maxsize=16)
def filter_alignments(
    ani_threshold,
    selected_group,
    max_n_genomes,
    min_pctid,
    min_cov,
    min_genes_per_genome
):
    """
    Filter the alignments for genomes in the selected group
    based on pident, coverage, and the number of genes aligned per genome.
    """

    # Get the logger
    logger = logging.getLogger('gig-map')
    logger.info(f"Selected Group: {selected_group}")
    logger.info(f"Max Genomes: {max_n_genomes}")
    logger.info(f"Minimum Percent Identity: {min_pctid}")
    logger.info(f"Minimum Coverage: {min_cov}")
    logger.info(f"Minimum Genes per Genome: {min_genes_per_genome}")

    # Get the genome groups based on this ANI threshold
    genome_groups = read_genome_groups(ani_threshold)

    # Filter by genome group
    genomes_in_selected_group = set([
        n
        for n, i in genome_groups.items()
        if i == selected_group
    ])
    filtered_alignments = data["alignments"].loc[
        data["alignments"]["genome_name"].isin(genomes_in_selected_group)
    ]
    logger.info(f"Filtered by genome group - {filtered_alignments.shape[0]:,} lines")

    # Filter by alignment quality
    filtered_alignments = filtered_alignments.query(
        f"pident >= {min_pctid}"
    ).query(
        f"coverage >= {min_cov}"
    ).assign(
        mask = True
    )
    logger.info(f"Filtered by alignment quality - {filtered_alignments.shape[0]:,} lines")

    # Count up the number of genes per genome
    genes_per_genome = filtered_alignments.genome_ix.value_counts()

    # Set a maximum number of genomes to retain
    genes_per_genome = genes_per_genome.head(max_n_genomes)

    # Apply the minimum threshold of the number of genes per genome
    genomes_passing_filter = set(genes_per_genome.index.values[
        genes_per_genome >= min_genes_per_genome
    ])
    genomes_passing_filter = set(list(genomes_passing_filter))

    logger.info(f"{len(genomes_passing_filter):,} genomes")

    # Only keep a single alignment per gene / genome
    filtered_alignments = filtered_alignments.groupby(
        ["genome_ix", "gene_ix"]
    ).head(1)
    logger.info(f"Deduplicated alignments - {filtered_alignments.shape[0]:,} lines")

    # Filter the alignments to only include those genomes which pass the filter
    filtered_alignments = filtered_alignments.loc[
        filtered_alignments.genome_ix.isin(genomes_passing_filter)
    ]
    logger.info(f"Filtered by final genome set - {filtered_alignments.shape[0]:,} lines")

    return filtered_alignments


def get_gene_annot_values(selections):
    """Return a dict with the specified annotation for 'color-genes-by'."""

    # Make sure that the specified value is in the annotation table
    assert selections["color-genes-by"] in data["gene_annotations"].columns.values

    # Make a dict with numeric values
    value_dict = data[
        "gene_annotations"
    ][
        selections["color-genes-by"]
    ].apply(
        lambda v: pd.to_numeric(v, errors="coerce")
    ).dropna(
    ).to_dict()

    # Make sure that there are at least some numeric values
    msg = f"Column {selections['color-genes-by']} contains no numeric values"
    assert len(value_dict) > 0, msg

    return value_dict


def read_genome_groups(ani_threshold):
    """Read in the assignment of genomes to groups at a particular ANI threshold."""
    return data[
        f"genome_groups {ani_threshold}"
    ].set_index(
        "genome"
    )[
        "group"
    ]


def plot_genome_group_overview(_, selections):
    """Render the genome overview display."""

    # Get the logger
    logger = logging.getLogger('gig-map')

    # Get the genome groups based on this ANI threshold
    ani_threshold = selections["ani-threshold"]
    logger.info(f"Plotting groups at {ani_threshold} percent identity")
    genome_groups = read_genome_groups(ani_threshold)
    
    # A summary of each genome group
    genome_group_df = data[f"genome_group_df {ani_threshold}"]
    
    # The mean ANI between groups
    group_distance_df = data[f"group_distance_df {ani_threshold}"]

    # If there is only one group
    if genome_groups.unique().shape[0] <= 1:

        # Return an empty plot
        fig = go.Figure()
        fig.update_layout(
            paper_bgcolor='white',
            plot_bgcolor='white',
            height=10,
            width=10,
        )
        return fig


    # Apply the maximum number of groups to display
    groups_to_plot = genome_group_df.head(
        selections["max-n-groups"]
    ).index.values
    group_distance_df = group_distance_df.reindex(
        index=groups_to_plot,
        columns=groups_to_plot
    )

    # Set the diagonal to zero and make symmetric
    for i in range(group_distance_df.shape[0]):
        group_distance_df.iloc[i, i] = 0
        for j in range(i):
            group_distance_df.iloc[i, j] = group_distance_df.iloc[j, i]

    # Get the positions of the nodes in the tree
    group_node_positions = get_node_positions(
        group_distance_df,
        y_offset=-0.5,
    )

    # Set up a base level figure
    fig = go.Figure()

    # Render the tree with multiple traces
    logger.info("Plotting tree")
    for trace in plot_tree(
        group_node_positions,
        selections,
        xaxis="x",  # Primary X axis
        yaxis="y",  # Primary Y axis
        try_relabel=False,
    ):
        fig.add_trace(
            trace
        )

    # Set up the labels for the genome groups to add to the axis
    genome_labels = [
        "Group #{} ({:,} {}, {:,} genes)".format(
            group_ix,
            genome_group_df.loc[group_ix, "n_genomes"],
            "genome" if genome_group_df.loc[group_ix, "n_genomes"] == 1 else "genomes",
            genome_group_df.loc[group_ix, "n_genes"],
        )
        for group_ix in map(int, group_node_positions.genome_order)
    ]

    # Set up the layout
    logger.info("Updating layout")
    fig.update_layout(
        # Set up the primary x-axis (with the tree)
        xaxis=dict(
            title_text="Genome Distance (ANI)",
        ),
        # Primary y-axis (with the tree)
        yaxis=dict(
            tickmode="array",
            tickvals=list(range(len(genome_labels))),
            ticktext=genome_labels,
            side="right",
            showticklabels=True,
        ),
        paper_bgcolor='white',
        plot_bgcolor='white',
        # Figure height and width
        height=(group_distance_df.shape[0] * 25) + 150,
        width=650,
    )

    logger.info("Rendering plot")

    return fig


def plot_gig_map_heatmap(selected_group, selections):
    """Render the heatmap + tree display."""

    # Get the logger
    logger = logging.getLogger('gig-map')

    # Filter the alignments using the thresholds set by the user
    logger.info("Filtering alignments")
    plot_df = filter_alignments(
        selections["ani-threshold"],
        selected_group,
        selections["max-n-genomes"],
        selections["minimum-pctid"],
        selections["minimum-coverage"],
        selections["minimum-genes-per-genome"]
    )

    # If the user wants to color by gene annotation
    if selections["color-genes-by"] not in ["pident", "coverage"]:

        # Get the values for each gene as a dict
        logger.info(f"Getting values for {selections['color-genes-by']}")
        value_dict = get_gene_annot_values(selections)

        # Add that column to the DataFrame
        logger.info(f"Adding column for {selections['color-genes-by']}")
        plot_df = plot_df.assign(
            **{
                selections["color-genes-by"]: plot_df["gene_ix"].apply(
                    lambda i: value_dict.get(data["gene_ix"][i])
                )
            }
        )

        # Filter down to just those genes the selected annotation
        plot_df = plot_df.loc[
            plot_df[selections["color-genes-by"]].apply(pd.notnull)
        ]

    # Count up the number of unique genomes and genes
    logger.info("Getting genome names")
    unique_genomes = list(map(
        lambda i: data["genome_ix"][i],
        plot_df.genome_ix.unique()
    ))
    unique_genes = plot_df.gene_ix.unique()

    logger.info("{:,} genomes, {:,} genes, {:,} alignments".format(
        len(unique_genomes),
        len(unique_genes),
        plot_df.shape[0]
    ))

    # Make sure that there are at least three genomes with alignments
    assert len(unique_genomes) >= 3, "At least three genomes are needed to display a comparison"

    # Create a tree using the set of genomes which contain alignments
    node_positions = make_nj_tree(unique_genomes, data['distances'])

    logger.info("Grouped genomes by ANI")

    # The figure will render with a dendrogram on the left and a heatmap on the right

    # Set up a base level figure
    fig = go.Figure()

    # Render the tree with multiple traces
    logger.info("Plotting tree")
    for trace in plot_tree(
        node_positions,
        selections,
        xaxis="x",  # Primary X axis
        yaxis="y",  # Primary Y axis
    ):
        fig.add_trace(
            trace
        )

    # Render the heatmap
    logger.info("Plotting heatmap")
    fig.add_traces(
        plot_heatmap(
            plot_df,
            node_positions,
            selections,
            xaxis="x2",  # Secondary X axis
            yaxis="y",   # Primary Y axis
        )
    )

    # Render the colorbar
    logger.info("Plotting colorbar")
    fig.add_trace(
        plot_colorbar(
            min_val=plot_df[
                selections["color-genes-by"]
            ].min(),
            max_val=plot_df[
                selections["color-genes-by"]
            ].max(),
            color_genes_by=selections["color-genes-by"],
            label={
                i['value']: i['label']
                for i in data["available_gene_annotations"]
            }[
                selections["color-genes-by"]
            ],
            colorscale=selections["heatmap-colorscale"],
            xaxis="x3",  # Tertiary X axis
            yaxis="y2",  # Secondary Y axis
        )
    )

    # Set up the labels for the genomes to add to the axis
    genome_labels = list(node_positions.genome_order)

    # If the user elected to label the genomes by something other than their ID
    if selections["label-genomes-by"] != "":

        # Map the labels to the values from the annotation table
        genome_labels = list(map(
            lambda l: data["genome_annotations"][selections["label-genomes-by"]].get(l, l),
            genome_labels
        ))

    # Set up the layout
    logger.info("Updating layout")
    fig.update_layout(
        # Set up the title of the plot
        title=f"Genome Group {selected_group}",
        # Set up the primary x-axis (with the tree)
        xaxis=dict(
            title_text="Genome Distance (ANI)",
            domain=[0, selections["tree-width"]],
            range=[
                node_positions.df['x'].max() * -0.01,
                node_positions.df['x'].max() * 1.01,
            ]
        ),
        # Primary y-axis (with the tree)
        yaxis=dict(
            tickmode="array",
            tickvals=list(range(len(genome_labels))),
            ticktext=[
                l[:selections["max-genome-label-len"]]
                for l in genome_labels
            ],
            side="right",
            anchor="x3",
            showticklabels=True,
            domain=[0, 0.9]
        ),
        # Secondary y-axis (with the colorbar)
        yaxis2=dict(
            anchor="x2",
            showticklabels=True,
            domain=[0.91, 1.0]
        ),
        # Secondary x-axis (with the heatmap),
        xaxis2=dict(
            domain=[selections["tree-width"], 1.0],
        ),
        # Tertiary x-axis (with the colorbar),
        xaxis3=dict(
            domain=[selections["tree-width"], 1.0],
            anchor="y2",
            side="top",
        ),
        paper_bgcolor='white',
        plot_bgcolor='white',
        # Figure height and width
        height=selections['figure-height'],
        width=selections['figure-width'],
    )
    logger.info("Rendering plot")

    return fig


def add_callbacks(app):
    """Decorate the callback needed to render the heatmap display."""

    @app.callback(
        Output("selected_group", "children"),
        [
            Input("genome-group-tree", "clickData")
        ]
    )
    def save_selected_genome_group(clickData):
        """Keep track of which genome group is being viewed."""

        # Get the logger
        logger = logging.getLogger('gig-map')

        # If the user has clicked on a group
        if isinstance(clickData, dict):
            if "points" in clickData:
                if isinstance(clickData["points"], list):
                    if len(clickData["points"]) == 1:
                        if isinstance(clickData["points"][0], dict):
                            if "text" in clickData["points"][0]:
                                if clickData["points"][0]["text"] is not None:
                                    selected_group = int(
                                        clickData["points"][0]["text"]
                                    )
                                    logger.info(f"Selected group: {selected_group}")

                                    return selected_group
        
        # Otherwise, if the user has not clicked on a group
        # Then just display the first group
        logger.info("No group has been selected, default to 0")
        return 0

    @app.callback(
        [
            Output("gig-heatmap", "figure"),
            Output(f"gig-heatmap-toast", "is_open"),
            Output(f"gig-heatmap-toast", "children")
        ],
        [
            Input("selected_group", "children"),
            Input({"menu": ALL, "elem": "redraw-button"}, "n_clicks"),
            Input({"menu": ALL, "elem": "close-button"}, "n_clicks"),
            Input({"menu": ALL, "elem": "open-button"}, "n_clicks"),
            Input("current-settings", "children"),
        ]
    )
    def heatmap_callback(
        selected_group,
        redraw_clicks,
        close_clicks,
        open_clicks,
        selected_params
    ):

        logger.info(f"Selected group for heatmap: {selected_group}")
        
        # If no group has been selected
        if selected_group is None:

            # Do not render the plot
            logger.info("Cannot render heatmap, stopping")
            raise PreventUpdate

        # Otherwise, a group has been selected

        # If the open buttons have never been pressed
        if all([v is None for v in open_clicks]):

            # Then let's go ahead and redraw the figure, since this
            # callback must have been triggered by the default
            # parameters loading
            pass

        # Otherwise
        else:

            # Get the element which triggered the callback
            trigger = ctx.triggered[0]['prop_id']

            # If this was triggered by the user clicking "Close and Redraw",
            #  or if a new group was selected
            if "close-button" in trigger or "redraw-button" in trigger or "selected_group" in trigger:

                # Then we will redraw the figure
                pass

            # Otherwise
            else:

                # Do not redraw the figure
                raise PreventUpdate

        # Parse the parameters from the serialized JSON
        selected_params = json.loads(selected_params)

        # Try to render the figure
        try:

            # Generate a figure object
            fig = plot_gig_map_heatmap(selected_group, selected_params)

            # If everything went well, just show the figure
            return fig, False, None

        # If there was an error
        except Exception as e:

            # Format a message to display
            msg = f"Unable to render -- {e}"
            logger.info(f"Encountered error: {e}")

            # Show an empty figure, and open the notification
            return empty_plot(), True, msg

# If the user provided initial settings
if args.settings is not None:

    # If the string points to a file
    if os.path.exists(args.settings):

        # Read in the file as JSON
        with open(args.settings, 'r') as handle:

            initial_settings = json.load(handle)

# Otherwise
else:

    # There are no initial settings
    initial_settings = dict()

# If the user specified --color-genes-by
if args.color_genes_by is not None:

    # Add that to the initial settings
    initial_settings["color-genes-by"] = args.color_genes_by

# Instantiate the MenuDrivenFigure object
mdf = MenuDrivenFigure(
    data=data,
    menus=menus,
    function=plot_genome_group_overview,
    # Set up two distinct plots
    figures=["genome-group-tree", "gig-heatmap"],
    # Add a hidden Div for the selected genome group
    state_variables=["selected_group"],
    title="Genes in Genomes Map",
    initial_settings=initial_settings
)

# Decorate additional callbacks
add_callbacks(mdf.app)

# Launch the Dash/Flask app
mdf.run_server(
    host='0.0.0.0',
    port=8080,
    debug=False,
)