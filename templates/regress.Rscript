#!/usr/bin/env Rscript

# Get the arguments passed in by the user

library(tidyverse)
library(rigr)
library(parallel)

main <- function(){

    ##  READCOUNTS CSV should have sample IDs in the first col
    ##  METADATA CSV should have a column `specimen` (which matches up with the first column from
    ##         the recounts file), and additional columns with covariates matching `formula`

    ##  rigr:regress analysis (coefficients and p-values) are written to OUTPUT CSV on completion

    print("Reading in ${input_metadata_csv}")
    metadata <- read_delim("${input_metadata_csv}", delim=",")
    metadata <- tibble::column_to_rownames(metadata, names(metadata)[1])
    metadata <- metadata %>% rownames_to_column(var = "specimen")
    print(head(metadata))
    print(dim(metadata))

    print("Reading in input.abund.csv")
    counts <- read_delim("input.abund.csv", delim=",")
    print(dim(counts))

    # If there aren't enough samples passing the threshold, stop gracefully
    if(dim(counts)[1] <= 2){
        print("Not enough samples to run rigr:regress -- stopping")
        return()
    }

    # Drop any rows from the metadata which lack a value in the formula string
    print("Dropping rows from metadata which lack a value in the formula string: ${params.formula}")
    for(cname in strsplit("${params.formula}", " ")[[1]]){
        if(cname %in% colnames(metadata)){
            metadata <- metadata[!is.na(metadata[[cname]]),]
        }
    }
    print(dim(counts))
    print(dim(metadata))

    # Get the specimens which are present in both tables
    specimens <- intersect(counts\$specimen, metadata\$specimen)
    print(paste(c("Specimens shared in both tables:", length(specimens)), collapse=" "))

    # Subset the counts to only have the rows which were retained in the metadata
    print("Aligning sample order between metadata and counts")
    counts <- counts %>% filter(specimen %in% specimens) %>% arrange(specimen) %>% tibble::column_to_rownames("specimen")
    metadata <- metadata %>% filter(specimen %in% specimens) %>% arrange(specimen) %>% tibble::column_to_rownames("specimen")

    # Save the metadata and abundance tables which are used for the analysis
    write.csv(counts, "abund.csv")
    write.csv(metadata, "metadata.csv")

    print("Running rigr:regress with proportion ~ ${params.formula}")
    run_regress <- function(i){
        colname <- colnames(counts)[i]
        data <- metadata %>% add_column(proportion=counts[, i])
        res <- tryCatch(
            regress(
                fnctl = "mean",
                formula = proportion ~ ${params.formula},
                data = data
            ),
            error = function(cond){return(NULL)}
        )
        if(all(is.na(res))){return(NULL)}else{
            return(
                as.data.frame(coef(res))
                    %>% add_column(feature = colname)
                    %>% rownames_to_column(var = "parameter")
                    %>% rename(pvalue="Pr(>|t|)")
            )
        }
    }

    # Run rigr:regress on each column
    results <- mclapply(c(1:dim(counts)[2]), run_regress, mc.cores = ${task.cpus})

    # Filter out any rows which did not converge
    results <- results[sapply(results, is.data.frame)]
    output <- do.call(rbind, results)

    print(sprintf("Writing out %s rows to regress.results.csv", nrow(output)))
    write_csv(output, "regress.results.csv")
    print("Done")
}

main()